package com.bodycamera.ba.toolsimport android.app.Activityimport android.content.Contextimport android.nfc.NfcAdapterimport android.nfc.Tagimport android.nfc.tech.MifareClassicimport android.nfc.tech.MifareUltralightimport android.util.Logimport android.widget.Toastimport com.bodycamera.ba.util.BeepHelperimport java.io.IOExceptionimport java.util.concurrent.atomic.AtomicBoolean/** * rules of writing data for NFC m1 card * p:1000008,i:1000072 * p -> police id , i -> device id */class NFCController(private val context: Context) {    interface IOnNfcReaderListener{        fun onNfcReaderResult(result:String)    }    companion object{        const val TAG = "NFCController"    }    private var  mAdapter : NfcAdapter?=null    private var isRunning = AtomicBoolean(false)    private var mListener:IOnNfcReaderListener?=null    fun setListener(listener: IOnNfcReaderListener?){        mListener = listener    }    fun create(activity: Activity):Boolean{        mAdapter = NfcAdapter.getDefaultAdapter(activity)        if(mAdapter == null){            Toast.makeText(context,"NFC is not supported",Toast.LENGTH_SHORT)            return false        }        if(mAdapter?.isEnabled != true){            Toast.makeText(context,"NFC is not enabled",Toast.LENGTH_SHORT)            return false        }        mAdapter?.enableReaderMode(activity,  { tag->            var isUltralight = false            for( it in tag.techList){                Log.i(TAG, "start: it=$it")                if(it.contains("MifareUltralight")){                    isUltralight = true                    break                }            }            //Log.d(TAG,toHexString(tag.id))            if(isUltralight) {                readTag2(tag)            }else {                Toast.makeText(context,"NFC card type is not supported ",Toast.LENGTH_SHORT)            }        }, (NfcAdapter.FLAG_READER_NFC_A or        NfcAdapter.FLAG_READER_NFC_B or        NfcAdapter.FLAG_READER_NFC_F or        NfcAdapter.FLAG_READER_NFC_V or        NfcAdapter.FLAG_READER_NFC_BARCODE),        null)        isRunning.set(true)        return true    }    fun release(activity:Activity){        isRunning.set(false)        mListener = null        if(mAdapter?.isEnabled == true){            mAdapter?.disableReaderMode(activity)        }    }    private fun toHexString(byteArray: ByteArray):String{        val sb = StringBuilder()        var tmp = 0        for( byte in byteArray){            tmp = byte.toInt() and 0xFF            if(tmp < 16) sb.append("0")            sb.append(tmp.toString(16))        }        return sb.toString()    }    fun readTag2(tag: Tag):Boolean{        var mfc0 = MifareUltralight.get(tag)        if(mfc0 == null){            Log.e(TAG, "readTag2: MifareUltralight.get(tag) failed ", )            return false        }        try {            mfc0.connect()            val tmp = ByteArray(512)            var tmpIdx = 0            var hasStarted = false            var result = ByteArray(256)            // index 4 where data begins            for (i in 4 until 16) {                var data = mfc0.readPages(i)                tmp[i * 4] = data[0]                tmp[i * 4 + 1] = data[1]                tmp[i * 4 + 2] = data[2]                tmp[i * 4 + 3] = data[3]            }            var j = 0            while( j < (tmp.size -1)){                if(!hasStarted){                    //starts with zh (0x7A,0x68)                    if(tmp[j].toInt() == 0x7A && tmp[j+1].toInt() == 0x68){                        hasStarted = true                        j += 2                        continue                    }                }else {                    if (tmp[j].toInt() == -0x2) {                        break                    } else if (tmp[j + 1].toInt() == -0x2) {                        result[tmpIdx++] = tmp[j]                        break                    }                    result[tmpIdx++] = tmp[j]                }                j++            }            if(tmpIdx > 0) findKeys(result,tmpIdx)        }catch (ex:IOException){            Log.e(TAG, "readTag2: failed", ex)            return false        }finally {            mfc0.close()        }        return true    }    private fun findKeys(byteArray: ByteArray, length:Int){        //p:1000008,i:1000072        //p -> police id , i -> device id        val data = String(byteArray,0, length)        /*val tmpArray = data.split(",")        val result = mutableMapOf<String,String>()        if(tmpArray.isNotEmpty()) {            for (str in tmpArray) {                var tmpArray2 =  str.split(":")                if(tmpArray2.size == 2){                    var key = tmpArray2[0].trim()                    var value = tmpArray2[1].trim()                    if(key.isNotEmpty() && value.isNotEmpty()){                        result[key] = value                        Log.e(TAG, "findKeys: key=$key,value=$value", )                    }                }            }        }        if(result.containsKey("p")){            ConfigHelper.putString(ConfigHelper.CONFIG_POLICE_USER_ID,result["p"])            Log.e(TAG, "findKeys: p = ${result["p"]}", )        }*/       if(isRunning.get()){           BeepHelper.success(context)           mListener?.onNfcReaderResult(data)       }    }     fun readTag(tag:Tag,sectorIndex:Int ){         var mfc = MifareClassic.get(tag)         var mfc0 = MifareUltralight.get(tag)         if(mfc == null){             Log.e(TAG, "readTag: mfc == NULL", )         }        for(tech in tag.techList){            Log.i(TAG, "readTag: tech=${tech}")        }         try {             mfc.connect()             val sectorCount = mfc.sectorCount             val typeDesc = when(mfc.type){                 MifareClassic.TYPE_CLASSIC -> "TYPE_CLASSIC"                 MifareClassic.TYPE_PLUS -> "TYPE_PLUS"                 MifareClassic.TYPE_PRO -> "TYPE_PRO"                 MifareClassic.TYPE_UNKNOWN -> "TYPE_UNKNOWN"                 else -> "TYPE_UNKNOWN"             }             val descBuilder = StringBuilder()             descBuilder.append("card type:${typeDesc}\n")             descBuilder.append("sectorCount:${sectorCount}\n")             descBuilder.append("blockCount:${mfc.blockCount}\n")             descBuilder.append("capacity:${mfc.size} bytes\n")             var blockIndex = 0             var blockCount = 0             if(mfc.authenticateSectorWithKeyA(sectorIndex,                     byteArrayOf(0x42,0x53,0x4B,sectorIndex.toByte(),0x4C,0x53))){                 blockIndex = mfc.sectorToBlock(sectorIndex)                 blockCount = mfc.getBlockCountInSector(sectorIndex)                 for(blc in 0 until  blockCount){                     Log.i(TAG, "readTag: secIndex=${sectorIndex},blockIndex=${blc},data=${String(mfc.readBlock(blc))}")                 }                 val data = mfc.readBlock(blockIndex)                 descBuilder.append("old card,sector index =${sectorIndex},block index=${blockIndex},content=${String(data)}\n")             }else if(mfc.authenticateSectorWithKeyA(sectorIndex,MifareClassic.KEY_NFC_FORUM)){                 blockIndex = mfc.sectorToBlock(sectorIndex)                 blockCount = mfc.getBlockCountInSector(sectorIndex)                 for(blc in 0 until  blockCount){                     Log.i(TAG, "readTag: secIndex=${sectorIndex},blockIndex=${blc},data=${String(mfc.readBlock(blc))}")                 }                 val data = mfc.readBlock(blockIndex)                 descBuilder.append("new card0,sector index =${sectorIndex},block index=${blockIndex},content=${String(data)}\n")             }else {                 descBuilder.append("sector index =${sectorIndex},block index=${blockIndex},verified failed\n")             }             Log.e(TAG, "readTag: content = $descBuilder", )         }catch (ex:IOException){             Log.e(TAG, "readTag: failed", ex)         }finally {             try {mfc?.close()}catch (ex:IOException){}         }    }}